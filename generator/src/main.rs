mod category;
mod generate;
mod parse;
mod renames;

use std::{
    collections::BTreeMap,
    error::Error,
    fs::{self, OpenOptions},
    io::{Read, Write},
};

use parse::{Define, Expression};

const HEADER: &str = r#"
// This file is generated.
//
// Do NOT edit this file, instead modify the generator.
"#;

fn main() -> Result<(), Box<dyn Error>> {
    let mut content = String::new();

    {
        let mut open = OpenOptions::new()
            .read(true)
            .open(&std::env::current_dir()?.join("input-event-codes.h"))?;

        open.read_to_string(&mut content)?;
    }

    let (remaining, mut defines) = parse::parse_file(&content).expect("parse error");

    if !remaining.is_empty() {
        panic!("Part of file is remaining: {}", remaining);
    }

    let mut previous_unresolved = None;

    // Resolve all the deferred defines.
    loop {
        // In order to not loop infinitely, first figure out how many unresolved defines we have.
        let unresolved = defines
            .iter()
            .filter(|define| matches!(define.expression, Expression::Expression { .. }))
            .count();

        // Are we done?
        if unresolved == 0 {
            break;
        }

        // Check if the unresolved count has changed
        if let Some(previous) = previous_unresolved {
            if previous == unresolved {
                // We have an infinite loop, break.
                // TODO: Better error message
                panic!(
                    "Some deferred defines have no expanded value: {:?}",
                    defines
                        .iter()
                        .filter(|define| matches!(define.expression, Expression::Expression { .. }))
                        .collect::<Vec<_>>()
                );
            }
        }

        // Store the current count to test for the next iteration.
        previous_unresolved = Some(unresolved);

        // Try to resolve some deferred defines.
        for index in 0..defines.len() {
            let define = *defines.get(index).unwrap();

            // Look up the deferred value
            if let Expression::Expression { other, add } = define.expression {
                if let Some(Define {
                    expression: Expression::Constant(value),
                    ..
                }) = defines.iter().find(|define| define.name == other)
                {
                    let value = *value;

                    // Since our deferred value is some, fill in the constant value.
                    let define = defines.get_mut(index).unwrap();
                    define.expression = Expression::Constant(value + add.unwrap_or(0));
                }
            }
        }
    }

    let categories = category::create_categories(defines)?;

    let mut category_tokens = BTreeMap::new();

    for (category_name, category) in categories {
        // Before we go any further, normalize the category name to rust-like naming.
        let mut category_enum_name = category_name.to_owned();
        category_enum_name
            .get_mut(0..1)
            .unwrap()
            .make_ascii_uppercase();
        category_enum_name
            .get_mut(1..)
            .unwrap()
            .make_ascii_lowercase();

        // TODO: Category renames
        assert!(category_tokens
            .insert(
                category_enum_name.clone(),
                generate::category_to_tokens(&category_enum_name, &category)?
            )
            .is_none());
    }

    let out_path = &std::env::current_dir()?.join("src").join("generated.rs");

    // Remove old generated file if it exists
    let _ = fs::remove_file(out_path);

    {
        println!("{}", out_path.display());
        let mut file = OpenOptions::new()
            .create(true)
            .write(true)
            .append(false)
            .open(out_path)?;

        writeln!(file, "{}", HEADER)?;

        for tokens in category_tokens.values() {
            writeln!(file, "{}", tokens.to_string())?;
        }

        file.flush()?;
    }

    Ok(())
}

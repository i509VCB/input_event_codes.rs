use std::{
    collections::HashSet,
    error::Error,
    fmt::{self, Display, Formatter},
    fs::OpenOptions,
    io::Write,
    num::ParseIntError,
    process::{Command, Stdio}, time::Duration,
};

use proc_macro2::{Ident, LexError, Literal, Span, TokenStream};
use quote::quote;
use syn::parse::{ParseBuffer, Parser};

const HEADER: &str = r#"
// This file is generated.
//
// Do NOT edit this file, instead modify the generator.
"#;

fn main() -> Result<(), Box<dyn Error>> {
    let generated = match bindgen::Builder::default()
        .header("./input-event-codes.h")
        // The header will only contain defines.
        // The header does say there may be typedefs but none are declared.
        .ignore_functions()
        .ignore_methods()
        .rustfmt_bindings(true)
        .generate()
    {
        Ok(generated) => Ok(generated.to_string()),

        // Bindgen should provide a nicer error in the future: https://github.com/rust-lang/rust-bindgen/pull/2125
        Err(_) => Err(GenerateError::Bindgen),
    }?;

    // Now perform the incredibly cursed parsing the source from bindgen to create a more idomatic api.
    // TODO: Could bindgen give us the token stream directly in the future?
    let tokens = generate_input_codes(&generated)?;
    let output = tokens.to_string();

    let mut path = std::env::current_dir()?;
    path.extend(["src", "generated.rs"]);

    let mut file = OpenOptions::new()
        .create(true)
        .write(true)
        .append(false)
        .open(&path)?;

    writeln!(file, "{}", HEADER)?;
    write!(file, "{}", output)?;
    file.flush()?;

    // Dismiss the file for formatting.
    drop(file);

    std::thread::sleep(Duration::from_secs(2));

    // Now run cargo fmt on the file.
    let output = Command::new("rustfmt")
        .arg(&path)
        .stderr(Stdio::null())
        .stdout(Stdio::null())
        .output()?;

    if !output.status.success() {
        panic!("Error while running \"rustfmt\": {}", output.status);
    }

    Ok(())
}

/// Generate enums representing all the input event codes.
///
/// This macro will create an enum for every entry inside `input-event-codes.h`.
fn generate_input_codes(generated: &str) -> Result<TokenStream, GenerateError> {
    let tokens: TokenStream = generated.parse()?;

    // Parse every single const item in the file, there should only be const items.
    let mut consts = Parser::parse2(
        |buffer: &ParseBuffer<'_>| -> syn::Result<Vec<syn::ItemConst>> {
            let mut items = vec![];

            while !buffer.is_empty() {
                items.push(buffer.parse()?);
            }

            Ok(items)
        },
        tokens,
    )?;

    // Create categories of the definitions in the input event codes header.
    let categories = consts
        .iter()
        // The category name is simply everything before the first `_`,
        .map(|item| item.ident.to_string().split_once('_').unwrap().0.to_owned())
        // Collect into a hash set so we do not have 100 category names called `KEY` and only 1.
        .collect::<HashSet<_>>()
        .into_iter()
        // Now take the entries from consts and put them in their categories
        .map(|name| {
            let mut entries = vec![];

            consts.retain(|item| {
                if item.ident.to_string().starts_with(&name) {
                    entries.push(item.clone());
                    // Remove element
                    false
                } else {
                    true
                }
            });

            Category { name, entries }
        })
        .collect::<Vec<_>>();

    if !consts.is_empty() {
        panic!("Entries not fully exhausted. This is a bug!");
    }

    // Generate enums
    let mut enums = Vec::with_capacity(categories.len());

    for category in categories {
        enums.push(generate_enum(category));
    }

    Ok(quote! { #(#enums)* })
}

fn generate_enum(mut category: Category) -> TokenStream {
    // TODO: Category name replacement, `Ev` is a badly named enum for example.

    // Normalize the name to Rust standards.
    category.name.get_mut(0..1).unwrap().make_ascii_uppercase();
    category.name.get_mut(1..).unwrap().make_ascii_lowercase();

    let name = Ident::new(&category.name, Span::call_site());

    let entries = category
        .entries
        .into_iter()
        .map(|item| {
            let mut name = item
                .ident
                .to_string()
                .split('_')
                .skip(1) // Skip the category name
                // Combine all segments
                .collect::<String>();

            // Prefix any entries that start with a number
            if name.starts_with(char::is_numeric) {
                name.insert(0, '_');
            }

            let ident = Ident::new(&name, Span::call_site());
            let original_name = Literal::string(&item.ident.to_string());

            match *item.expr {
                syn::Expr::Lit(syn::ExprLit {
                    lit: syn::Lit::Int(value),
                    ..
                }) => {
                    let value = Literal::u32_unsuffixed(value.base10_parse::<u32>().unwrap());

                    Entry {
                        ident,
                        original_name,
                        value,
                    }
                }

                _ => {
                    panic!("Expression value of {} is not a literal", name)
                }
            }
        })
        .collect::<Vec<_>>();

    let entries = entries
        .iter()
        .map(|entry| {
            let ident = &entry.ident;
            let value = &entry.value;
            let alias = &entry.original_name;

            // With the definition, we also include the original name before any processing for easy searching.
            quote! {
                #[doc(alias = #alias)]
                pub const #ident: #name = #name(#value);
            }
        })
        .collect::<Vec<_>>();

    // TODO: Note how the ordering may not mean anything
    quote! {
        #[repr(transparent)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub struct #name (u32);

        impl #name {
            pub const fn new(value: u32) -> #name {
                #name(value)
            }

            pub const fn into_inner(self) -> u32 {
                self.0
            }
        }

        impl From<u32> for #name {
            fn from(value: u32) -> #name {
                #name(value)
            }
        }

        impl From<#name> for u32 {
            fn from(value: #name) -> u32 {
                value.0
            }
        }

        impl PartialEq<u32> for #name {
            fn eq(&self, other: &u32) -> bool {
                &self.0 == other
            }
        }

        impl #name {
            #(#entries)*
        }
    }
}

struct Category {
    name: String,
    entries: Vec<syn::ItemConst>,
}

struct Entry {
    ident: Ident,
    original_name: Literal,
    value: Literal,
}

#[derive(Debug)]
enum GenerateError {
    /// Bindgen failed to generate bindings to input-event-codes.h
    Bindgen,

    /// The code generated by bindgen was invalid
    Lex(LexError),

    /// Syn encountered an error while parsing.
    Parse(syn::Error),

    /// An int literal could not be parsed.
    ParseInt(ParseIntError),
}

impl From<LexError> for GenerateError {
    fn from(err: LexError) -> Self {
        GenerateError::Lex(err)
    }
}

impl From<syn::Error> for GenerateError {
    fn from(err: syn::Error) -> Self {
        GenerateError::Parse(err)
    }
}

impl From<ParseIntError> for GenerateError {
    fn from(err: ParseIntError) -> Self {
        GenerateError::ParseInt(err)
    }
}

impl Display for GenerateError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            GenerateError::Bindgen => write!(f, "bindgen"),
            GenerateError::Lex(err) => Display::fmt(err, f),
            GenerateError::Parse(err) => Display::fmt(err, f),
            GenerateError::ParseInt(err) => Display::fmt(err, f),
        }
    }
}

impl Error for GenerateError {}
